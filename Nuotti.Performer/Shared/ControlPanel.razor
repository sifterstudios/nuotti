@using Nuotti.Contracts.V1.Enum
@using Nuotti.Contracts.V1.Model
@inject PerformerUiState State
@inject PerformerCommands Commands
@inject IDialogService Dialogs

<MudPaper Elevation="2" Class="pa-4">
    <MudText Typo="Typo.h6" Class="mb-4">Flow Controls</MudText>
    <MudGrid>
        <MudItem xs="12" sm="6" md="4" lg="2">
            <MudButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" 
                       StartIcon="@Material.Filled.PlayArrow" 
                       OnClick="StartSet" Disabled="@(!CanStartSet)">
                Start Set
            </MudButton>
        </MudItem>
        <MudItem xs="12" sm="6" md="4" lg="2">
            <MudButton Variant="Variant.Filled" Color="Color.Secondary" FullWidth="true" 
                       StartIcon="@Material.Filled.SkipNext" 
                       OnClick="NextSong" Disabled="@(!CanNextSong)">
                Next Song
            </MudButton>
        </MudItem>
        <MudItem xs="12" sm="6" md="4" lg="2">
            <MudButton Variant="Variant.Filled" Color="Color.Info" FullWidth="true" 
                       StartIcon="@Material.Filled.Lightbulb" 
                       OnClick="GiveHint" Disabled="@(!CanGiveHint)">
                Give Hint
            </MudButton>
        </MudItem>
        <MudItem xs="12" sm="6" md="4" lg="2">
            <MudButton Variant="Variant.Filled" Color="Color.Warning" FullWidth="true" 
                       StartIcon="@Material.Filled.Lock" 
                       OnClick="LockAnswers" Disabled="@(!CanLock)">
                Lock Answers
            </MudButton>
        </MudItem>
        <MudItem xs="12" sm="6" md="4" lg="2">
            <MudButton Variant="Variant.Filled" Color="Color.Success" FullWidth="true" 
                       StartIcon="@Material.Filled.Visibility" 
                       OnClick="Reveal" Disabled="@(!CanReveal)">
                Reveal
            </MudButton>
        </MudItem>
        <MudItem xs="12" sm="6" md="4" lg="2">
            <MudButton Variant="Variant.Filled" Color="Color.Error" FullWidth="true" 
                       StartIcon="@Material.Filled.Stop" 
                       OnClick="EndSong" Disabled="@(!CanEndSong)">
                End Song
            </MudButton>
        </MudItem>
    </MudGrid>
</MudPaper>

@if (State.Phase == Phase.Lock && State.Choices.Count > 0)
{
    <MudPaper Elevation="1" Class="pa-4 mt-3">
        <MudText Typo="Typo.subtitle1" Class="mb-2">Select Correct Answer</MudText>
        <MudRadioGroup T="int?" ValueChanged="OnCorrectChanged" Value="@State.SelectedCorrectIndex">
            @for (var i = 0; i < State.Choices.Count; i++)
            {
                <MudRadio T="int?" Value="@i">@State.Choices[i]</MudRadio>
            }
        </MudRadioGroup>
        <MudText Typo="Typo.caption" Color="Color.Error" Hidden="@HasSelection">Please select the correct answer before revealing.</MudText>
    </MudPaper>
}

@code {
    bool HasSelection => State.SelectedCorrectIndex.HasValue;
    bool CanStartSet => State.Phase is Phase.Lobby or Phase.Finished;
    bool CanNextSong => State.Phase is Phase.Guessing && State.EngineCount > 0; // NextRound requires Engine
    bool CanGiveHint => State.Phase is Phase.Start or Phase.Hint or Phase.Guessing;
    bool CanLock => State.Phase is Phase.Guessing;
    bool CanReveal => State.Phase is Phase.Lock && HasSelection;
    bool CanEndSong => State.Phase is Phase.Play && State.EngineCount > 0; // Stop requires Engine

    async Task StartSet() => await Commands.StartSetAsync();
    async Task NextSong()
    {
        var songId = State.CurrentSong?.Id ?? new SongId("song-1");
        await Commands.NextSongAsync(songId);
    }
    async Task GiveHint()
    {
        var songId = State.CurrentSong?.Id ?? new SongId("song-1");
        var nextIndex = State.NextHintIndex;
        var hint = new Hint(nextIndex, null, null, songId);
        await Commands.GiveHintAsync(hint);
        // Optimistically increment; server snapshot will sync if different
        State.IncrementHintIndex();
    }
    async Task LockAnswers() => await Commands.LockAnswersAsync();
    void OnCorrectChanged(int? index)
    {
        State.SetSelectedCorrectIndex(index);
    }
    async Task Reveal()
    {
        if (State.CurrentSong is null || !State.SelectedCorrectIndex.HasValue) return;
        var idx = State.SelectedCorrectIndex.Value;
        var label = idx >= 0 && idx < State.Choices.Count ? State.Choices[idx] : $"Index {idx}";
        bool? confirmed = await Dialogs.ShowMessageBox(
            title: "Reveal Answer",
            markupMessage: (MarkupString)$"Reveal '<strong>{label}</strong>' as the correct answer?",
            yesText: "Reveal",
            cancelText: "Cancel");
        if (confirmed == true)
        {
            await Commands.RevealAsync(State.CurrentSong, idx);
        }
    }
    async Task EndSong()
    {
        if (State.CurrentSong is null) return;
        await Commands.EndSongAsync(State.CurrentSong.Id);
    }
}